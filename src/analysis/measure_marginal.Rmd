---
title: "R Notebook: estimation of gas costs using the measure marginal method; for Gas Cost Estimator"
output: html_notebook
---

```{r include=FALSE, fig.width=20}
library(sqldf)
library(nlme)
```


## Data preparations

Read in the `programs.csv` as generated by `src/program_generator.py` with `--fullCSV` flag on:
```{r fig.width=20}
setwd("~/sources/imapp/gas-cost-estimator/src")
programs = read.csv("../../local/pg_marginal_exp.csv")
```

Unfortunately `JUMP` and `JUMPI` are currently broken in `geth` (they require a `JUMPDEST`).
Because they work in `evmone` (it prepends `JUMPDEST`) forcefully, we should drop them from the analysis.
Also `RETURNDATACOPY` program generation is broken in general (`return data out of bounds`).

```{r fig.width=20}
programs = programs[which(programs$opcode != "JUMP"), ]
programs = programs[which(programs$opcode != "JUMPI"), ]
programs = programs[which(programs$opcode != "RETURNDATACOPY"), ]

# necessary to get rid of the factor levels which we just filtered out
programs = droplevels(programs)

head(programs)
```

Read in the `result_*.csv` as generated by `src/measurements.py`.

```{r fig.width=20}
setwd("~/sources/imapp/gas-cost-estimator/src")
result_geth = read.csv("../../local/geth_pg_marginal_exp_total_50_4.csv")
result_evmone = read.csv("../../local/evmone_pg_marginal_exp_total_50_4.csv")
# result_openethereum = read.csv("../../local/result_openethereum_all_50_4.csv")
result_geth$env = "geth"
result_evmone$env = "evmone"
# result_openethereum$env = "openethereum"
results = rbind(result_geth, result_evmone)
head(results)
```

Combine the two tables to see only times of the measured opcodes.

```{r fig.width=20}
measurements = sqldf("SELECT opcode, op_count, sample_id, run_id, measure_total_time_ns, env, results.program_id
                     FROM results
                     INNER JOIN
                       programs ON(results.program_id = programs.program_id)
                     ")

head(measurements)
```

### Remove outliers

Removing or not of the outliers has a large impact on the final results.
It seems that for `EXP` and `evmone` there are many outliers in the mid-low `op_count` samples.
This effectively "leverages" the estimated slope downwards, pretending `EXP`'s `evmone` to be cheaper than it really seems to be.

Switch `removed_outliers` to `FALSE` to see the comparison.

```{r}
remove_outliers <- function(df, col, selection_col, selection_val) {
  subset = df[which(df[, selection_col] == selection_val), ]
  outliers = boxplot(subset[, col] ~ subset[, 'op_count'] + subset[, 'env'], plot=FALSE)$out
  no_outliers = df[-which(df[, col] %in% outliers & df[, selection_col] == selection_val), ]
  return(no_outliers)
}

removed_outliers = TRUE

if (removed_outliers) {
  measurements = remove_outliers(measurements, 'measure_total_time_ns', 'env', 'geth')
  measurements = remove_outliers(measurements, 'measure_total_time_ns', 'env', 'evmone')
}

head(measurements)
```

### Trim the initial values

```{r}
# measurements = measurements[-(which(measurements$op_count < 15)), ]
```


```{r fig.width=15}
boxplot(measure_total_time_ns ~ op_count, data=measurements[which(measurements$env == 'geth'), ], las=2, outline=removed_outliers)
boxplot(measure_total_time_ns ~ op_count, data=measurements[which(measurements$env == 'evmone'), ], las=2, outline=removed_outliers)
```

```{r}
measurements_mean = aggregate(measure_total_time_ns ~ op_count * env, measurements, mean)
  
scatter.smooth(measurements_mean[which(measurements_mean$env == 'geth'), 'op_count'], measurements_mean[which(measurements_mean$env == 'geth'), 'measure_total_time_ns'])
scatter.smooth(measurements_mean[which(measurements_mean$env == 'evmone'), 'op_count'], measurements_mean[which(measurements_mean$env == 'evmone'), 'measure_total_time_ns'])
```

```{r}
model_mean_geth = lm(measure_total_time_ns ~ op_count, data=measurements_mean[which(measurements_mean$env == 'geth'), ])
model_mean_evmone = lm(measure_total_time_ns ~ op_count, data=measurements_mean[which(measurements_mean$env == 'evmone'), ])
summary(model_mean_geth)
summary(model_mean_evmone)
```

```{r}
model_geth = lm(measure_total_time_ns ~ op_count, data=measurements[which(measurements$env == 'geth'), ])
model_evmone = lm(measure_total_time_ns ~ op_count, data=measurements[which(measurements$env == 'evmone'), ])
summary(model_geth)
summary(model_evmone)
```


```{r fig.width=15}
par(mfrow=c(4,4))
plot(model_mean_geth)
plot(model_mean_evmone)
plot(model_geth)
plot(model_evmone)
```
