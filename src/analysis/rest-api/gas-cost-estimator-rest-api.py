import os
import os.path
import re
import shutil
import subprocess

from flask import Flask, request, jsonify, send_file, make_response

app = Flask(__name__)

@app.route('/', methods=['GET'])
def info():
    return '''
    <!doctype html>
    <title>Gas Cost Estimator - Generate Reports</title>
    <h1>Welcome</h1>
    <p>
      This is an info page.
      It helps to understand how to use this service.
    </p>
    <hr/>
    <p>
      To learn more on Gas Cost Estimator visit <a href="">the project site</a>.
      This is a RESTful service to generate reports. 
      The general flow is: you upload input data files and trigger a report processing,
      it can take a while so the job is asynchronous and you have to ask for the status, 
      wait for the report to be ready,
      download the report and output data file.
    </p>
    <p>
      There are demo pages for <a href="generate_marginal_report">the marginal report</a> 
      and <a href="generate_arguments_report">the arguments report</a>. 
    </p>
    <p>
      Endpoints:
      <ul style="list-style-type:none;">
        <li>GET /generate_marginal_report -- a demo page</li>
        <li>GET /generate_arguments_report -- a demo page</li>
        <li>POST /generate_marginal_report -- request a report generation, returns job_id</li>
        <li>POST /generate_arguments_report -- request a report generation, returns job_id</li>
        <li>GET /generate_marginal_report/<job_id> -- non cachable status check</li>
        <li>GET /generate_arguments_report/<job_id> -- non cachable status check</li>
        <li>GET /generate_marginal_report/<job_id>/report -- download the report file</li>
        <li>GET /generate_arguments_report/<job_id>/report -- download the report file</li>
        <li>GET /generate_marginal_report/<job_id>/estimated_cost -- download the output data file</li>
        <li>GET /generate_arguments_report/<job_id>/estimated_cost -- download the output data file</li>
      </ul> 
    </p>
    <hr/>
    <h2>
      Terms of Use
    </h2>
    <p>
      By using this service and/or related Gas Cost Estimator project works you agree and consent the following terms.
      <br/>
      This is an experimental software. Shipped with MIT license.
      <br/>
      The service is run with <a href="https://flask.palletsprojects.com/">Flask</a> (BSD License) 
      and <a href="https://uwsgi-docs.readthedocs.io/">uWSGI</a>  (GPLv2).
      Internally, R (language) scripts are executed to generate reports, <a href="https://www.r-project.org/">see</a> (GPLv2|GPLv3).
      <br/>
      A user consent that any input files and output files are sent to and from the service 
      and persisted solely for the purpose
      of a report generation. 
      These data are not publicly available through the service (protection with personal links with a random job_id).
      Gas Cost Estimator project and a service provider do not hold any responsibility
      for a harm or a loss incurred by a disclosure of these data. 
      A user hold all legal responsibility (e.g. to not violate any third party license) for using 
      these data with the service.
      All proprietary and rights to any input file remains to a user 
      and no proprietary or rights are transferred to Gas Cost Estimator project or a service provider.
      All proprietary and rights to any output file are granted to a user with an exception to the terms above.
      <br/>
      Gas Cost Estimator project or a service provider do not hold any responsibility for faults and delays and availability
      of the service.
      <br/>
      A user consent that this is a research tool, results are estimated and used statistical methods may not apply to all cases. 
      Gas Cost Estimator project or a service provider do not hold any responsibility for implications 
      or loss incurred by using reports and/or estimations generated by the service.
      <br/>
      A user undertakes not to take any action that intentionally results in the disabling, overloading or damaging of the service 
      or is aimed at obtaining unauthorized data.
    </p>
    '''

@app.route('/generate_marginal_report', methods=['GET'])
def generate_marginal_report_form():
    return '''
    <!doctype html>
    <title>Generate Marginal Report</title>
    <h1>Marginal Report</h1>
    <p>
      This is just a demo page.
      It helps to understand how to prepare the post request.
    </p>
    <form method=post enctype=multipart/form-data>
      EVM:
      <input type=text name=evm> 
      Optional if can be detected<br/>
      Details:
      <input type="checkbox" name="details" value="1"> <br/>
      Programs:
      <input type=file name=programs> <br/>
      Results:
      <input type=file name=results> <br/>
      <input type=submit value="Generate Report">
    </form>
    '''

@app.route('/generate_arguments_report', methods=['GET'])
def generate_arguments_report_form():
    return '''
    <!doctype html>
    <title>Generate Arguments Report</title>
    <h1>Arguments Report</h1>
    <p>
      This is just a demo page.
      It helps to understand how to prepare the post request.
    </p>
    <form method=post enctype=multipart/form-data>
      EVM:
      <input type=text name=evm> 
      Optional if can be detected<br/>
      Details:
      <input type="checkbox" name="details" value="1"> <br/>
      Programs:
      <input type=file name=programs> <br/>
      Results:
      <input type=file name=results> <br/>
      Marginal Estimated Cost file:
      <input type=file name=marginal>
      Optional, just for additional validation<br/>
      <input type=submit value="Generate Report">
    </form>
    '''

# TODO mime type?
# TODO error logging
@app.route('/generate_marginal_report', methods=['POST'])
def generate_marginal_report_execute():
    job_id = os.urandom(20).hex().lower()  # just in case

    if 'evm' not in request.form:
        return 'the evm form param is missing', 400
    if 'programs' not in request.files:
        return 'the programs file is missing', 400
    if 'results' not in request.files:
        return 'the results file is missing', 400

    details = '1' if 'details' in request.form and request.form['details'].lower() in ['1', 't', 'true', 'on'] else '0'

    programs = request.files['programs']
    results = request.files['results']
    if programs.filename == '':
        return 'the programs file is missing', 400
    if results.filename == '':
        return 'the results file is missing', 400

    measurement = '' # initialization just to stop code analyzer complains
    evm = ''
    results_filename_parsed = re.fullmatch('^results_marginal_([a-zA-Z0-9\\-_]+)_([a-zA-Z0-9\\-]+)\\.csv$', results.filename)
    # detect names
    if results_filename_parsed:
        measurement_type = results_filename_parsed.group(1)
        evm = results_filename_parsed.group(2)
        measurement = f'{measurement_type}_{evm}'
    if request.form['evm']:
        if not re.fullmatch('^[a-zA-Z0-9\\-]{1,64}$', request.form['evm']):
            return 'the evm name is invalid', 400
        if evm != request.form['evm']: # if evm == request.form['evm'] then it is not empty and detected
            evm = request.form['evm']
            measurement = job_id
    if not evm: # if evm then measurement is set
        return 'the evm form param is empty', 400

    try:
        os.mkdir(job_id)
    except OSError as err:
        print(err)
        return 'could not initialize the job', 500

    try:
        programs.save(f'{job_id}/programs.csv')
        results.save(f'{job_id}/results.csv')
    except OSError as err:
        print(err)
        try:
            shutil.rmtree(job_id)
        except OSError as err2:
            print(err2)
        return 'could not download files', 500

    try:
        with open(f'{job_id}/measurement', 'w') as measurement_file:
            measurement_file.write(measurement)

        command = ("Rscript -e "
                   f"\"rmarkdown::render('/reports/measure_marginal_single.Rmd', params = list(env = '{evm}', programs='{job_id}/programs.csv', results='{job_id}/results.csv', output_estimated_cost='{job_id}/estimated_cost.csv', details='{details}'), output_file = '/data/{job_id}/report.html', quiet = TRUE)\" "
                   f"> {job_id}/output 2> {job_id}/error ; "
                   f"echo $? > {job_id}/exitcode"
                   )
        # the invocation outside docker
        # command = (f"docker run -v {os.getcwd()}/{job_id}:/data "
        #            "--rm imapp-pl/gas-cost-estimator/reports:4.0 "
        #            "Rscript -e "
        #            f"\"rmarkdown::render('/reports/measure_marginal_single.Rmd', params = list(env = '{evm}', programs='programs.csv', results='results.csv', output_estimated_cost='estimated_cost.csv', details='{details}'), output_file = '/data/report.html', quiet = TRUE)\" "
        #            f"> {job_id}/output 2> {job_id}/error ; "
        #            f"echo $? > {job_id}/exitcode"
        #            )
        # shell=True is safe because the command contains only validated evm entry
        subprocess.Popen(command, shell=True)

        return jsonify(job_id=job_id)
    except OSError as err:
        print(err)
        try:
            shutil.rmtree(job_id)
        except OSError as err2:
            print(err2)
        return 'could not start the job', 500


# TODO mime type?
# TODO error logging
@app.route('/generate_arguments_report', methods=['POST'])
def generate_arguments_report_execute():
    job_id = os.urandom(20).hex().lower()  # just in case

    if 'evm' not in request.form:
        return 'the evm form param is missing', 400
    if 'programs' not in request.files:
        return 'the programs file is missing', 400
    if 'results' not in request.files:
        return 'the results file is missing', 400

    details = '1' if 'details' in request.form and request.form['details'].lower() in ['1', 't', 'true', 'on'] else '0'

    programs = request.files['programs']
    results = request.files['results']
    if programs.filename == '':
        return 'the programs file is missing', 400
    if results.filename == '':
        return 'the results file is missing', 400
    marginal_estimated_cost = request.files['marginal'] if 'marginal' in request.files and request.files['marginal'].filename else None

    measurement = '' # initialization just to stop code analyzer complains
    evm = ''
    results_filename_parsed = re.fullmatch('^results_arguments_([a-zA-Z0-9\\-_]+)_([a-zA-Z0-9\\-]+)\\.csv$', results.filename)
    # detect names
    if results_filename_parsed:
        measurement_type = results_filename_parsed.group(1)
        evm = results_filename_parsed.group(2)
        measurement = f'{measurement_type}_{evm}'
    if request.form['evm']:
        if not re.fullmatch('^[a-zA-Z0-9\\-]{1,64}$', request.form['evm']):
            return 'the evm name is invalid', 400
        if evm != request.form['evm']: # if evm == request.form['evm'] then it is not empty and detected
            evm = request.form['evm']
            measurement = job_id
    if not evm: # if evm then measurement is set
        return 'the evm form param is empty', 400

    try:
        os.mkdir(job_id)
    except OSError as err:
        print(err)
        return 'could not initialize the job', 500

    try:
        programs.save(f'{job_id}/programs.csv')
        results.save(f'{job_id}/results.csv')
        if marginal_estimated_cost:
            marginal_estimated_cost.save(f'{job_id}/marginal.csv')
    except OSError as err:
        print(err)
        try:
            shutil.rmtree(job_id)
        except OSError as err2:
            print(err2)
        return 'could not download files', 500

    try:
        with open(f'{job_id}/measurement', 'w') as measurement_file:
            measurement_file.write(measurement)

        marginal_estimated_cost_param = f", marginal_estimated_cost='{job_id}/marginal.csv'" if marginal_estimated_cost else ''
        command = ("Rscript -e "
                   f"\"rmarkdown::render('/reports/measure_arguments_single.Rmd', params = list(env = '{evm}', programs='{job_id}/programs.csv', results='{job_id}/results.csv', output_estimated_cost='{job_id}/estimated_cost.csv', details='{details}'{marginal_estimated_cost_param}), output_file = '/data/{job_id}/report.html', quiet = TRUE)\" "
                   f"> {job_id}/output 2> {job_id}/error ; "
                   f"echo $? > {job_id}/exitcode"
                   )
        # the invocation outside docker
        # command = (f"docker run -v {os.getcwd()}/{job_id}:/data "
        #            "--rm imapp-pl/gas-cost-estimator/reports:4.0 "
        #            "Rscript -e "
        #            f"\"rmarkdown::render('/reports/measure_arguments_single.Rmd', params = list(env = '{evm}', programs='programs.csv', results='results.csv', output_estimated_cost='estimated_cost.csv', details='{details}'{marginal_estimated_cost_param}), output_file = '/data/report.html', quiet = TRUE)\" "
        #            f"> {job_id}/output 2> {job_id}/error ; "
        #            f"echo $? > {job_id}/exitcode"
        #            )
        # shell=True is safe because the command contains only validated evm entry
        subprocess.Popen(command, shell=True)

        return jsonify(job_id=job_id)
    except OSError as err:
        print(err)
        try:
            shutil.rmtree(job_id)
        except OSError as err2:
            print(err2)
        return 'could not start the job', 500


@app.route('/generate_marginal_report/<job_id>', methods=['GET'])
def generate_marginal_report_status(job_id):
    return generate_base_report_status(job_id)

@app.route('/generate_arguments_report/<job_id>', methods=['GET'])
def generate_arguments_report_status(job_id):
    return generate_base_report_status(job_id)

def generate_base_report_status(job_id):
    if not re.fullmatch('^[0-9a-f]{40}$', job_id):
        return 'invalid job id', 400
    if not os.path.exists(job_id):
        response_content = jsonify(status='GONE')
    elif not os.path.exists(f'{job_id}/exitcode'):
        response_content = jsonify(status='RUNNING')
    else:
        # skip error checks, if output and/or error files do not exist then something went wrong anyway
        with open(f'{job_id}/exitcode', 'r') as exitcode_file:
            exitcode_str = exitcode_file.read()
            exitcode = int(exitcode_str.strip()) # the file contains new line
        with open(f'{job_id}/output', 'r') as stdout_file:
            stdout = stdout_file.read()
        with open(f'{job_id}/error', 'r') as stderr_file:
            stderr = stderr_file.read()
        response_content = jsonify(status='DONE', exitcode=exitcode, stdout=stdout, stderr=stderr)
    response = make_response(response_content)
    response.headers.add('Cache-Control', 'private, no-store, max-age=0')
    return response

@app.route('/generate_marginal_report/<job_id>/report', methods=['GET'])
def generate_marginal_report_get_report(job_id):
    return generate_base_report_get_file(job_id, 'report.html', 'report_marginal')

@app.route('/generate_marginal_report/<job_id>/estimated_cost', methods=['GET'])
def generate_marginal_report_get_estimated_cost(job_id):
    return generate_base_report_get_file(job_id, 'estimated_cost.csv', 'estimated_cost_marginal')

@app.route('/generate_arguments_report/<job_id>/report', methods=['GET'])
def generate_arguments_report_get_report(job_id):
    return generate_base_report_get_file(job_id, 'report.html', 'report_arguments')

@app.route('/generate_arguments_report/<job_id>/estimated_cost', methods=['GET'])
def generate_arguments_report_get_estimated_cost(job_id):
    return generate_base_report_get_file(job_id, 'estimated_cost.csv', 'estimated_cost_arguments')

def generate_base_report_get_file(job_id, filename, prefix):
    if not re.fullmatch('^[0-9a-f]{40}$', job_id):
        return 'invalid job id', 400
    if not os.path.exists(f'{job_id}/{filename}'):
        return 'the file is gone', 404
    if os.path.exists(f'{job_id}/measurement'):
        with open(f'{job_id}/measurement', 'r') as measurement_file:
            measurement = measurement_file.read()
    else:
        measurement = job_id
    return send_file(f'{os.getcwd()}/{job_id}/{filename}', as_attachment=True, download_name=f'{prefix}_{measurement}.html')
