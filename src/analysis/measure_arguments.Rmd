---
title: "R Notebook: estimation of impact of arguments on gas costs; for Gas Cost Estimator"
output: html_document
---

```{r include=FALSE, fig.width=20}
library(sqldf)
library(nlme)

# prevent scientific notation
options(scipen = 100)
```


## Data preparations

Read in the `programs.csv` as generated by `src/pg_arguments` with `--fullCSV` flag on:
```{r fig.width=20}
setwd("~/sources/imapp/gas-cost-estimator/src")

# The program set is 200 programs, with the count of measured OPCODE increases twice in steps of 15,
# so we have a program with 0, 15, and 30 measured OPCODEs 
program_set_codename = "full1_c200_opc15x2"
programs = read.csv(paste("../../local/pg_arguments_", program_set_codename, ".csv", sep=""))
```

Unfortunately `JUMP` and `JUMPI` are currently broken in `geth` (they require a `JUMPDEST`).
Because they work in `evmone` (it prepends `JUMPDEST`) forcefully, we should drop them from the analysis.
Also `RETURNDATACOPY` program generation is broken in general (`return data out of bounds`).

Read in the `result_*.csv` as generated by `src/measurements.py`. 

Invocation similar to: `sudo docker run   --rm   --privileged --security-opt seccomp:unconfined -v /home/ubuntu/pdobacz/local:/srv/local  -it gas-cost-estimator/evmone_total sh -c "cd src && cat /srv/local/pg_arguments_arithmetic_c50_opc10.csv | python3 instrumentation_measurement/measurements.py measure --evm evmone --mode total --sampleSize=50 --nSamples=4 > /srv/local/evmone_pg_arguments_arithmetic_c50_opc10_50_4.csv"`. 

```{r fig.width=20}
setwd("~/sources/imapp/gas-cost-estimator/src")

load_data_set <- function(env, program_set_codename, measurement_codename) {
  setwd("~/sources/imapp/gas-cost-estimator/src")
  data_set_codename = paste(program_set_codename, "_", measurement_codename, sep="")
  filepath = paste("../../local/", env, "_pg_arguments_", data_set_codename, ".csv", sep="")
  result = read.csv(filepath)
  result$env = env
  return(result)
}
measurement_codename = "50_1"

result_geth = load_data_set("geth", program_set_codename, measurement_codename)
result_evmone = load_data_set("evmone", program_set_codename, measurement_codename)
# was originally 400_4, but this goes over the memory, must reduce to less
result_openethereum = load_data_set("openethereum", program_set_codename, "200_2")
results = rbind(result_evmone, result_geth, result_openethereum)
# TODO geth short-circuits zero length programs, resulting in zero timing somehow. Drop these more elegantly, not based on measure_total_time_ns
results = results[which(results$measure_total_time_ns != 0), ]
head(results)
```

```{r fig.width=20}
measurements = sqldf("SELECT opcode, op_count, arg0, arg1, arg2, sample_id, run_id, measure_total_time_ns, env, results.program_id
                     FROM results
                     INNER JOIN
                       programs ON(results.program_id = programs.program_id)
                     ")
head(measurements)
```

```{r}
remove_outliers <- function(df, col) {
  boxplot_result = boxplot(df[, col] ~ df[, 'op_count'] + df[, 'env'] + df[, 'opcode'], plot=FALSE)
  outliers = boxplot_result$out
  names = boxplot_result$names[boxplot_result$group]
  all_row_identifiers = paste(df[, col], df[, 'op_count'], df[, 'env'], df[, 'opcode'], sep='.')
  outlier_row_identifiers = paste(outliers, names, sep='.')
  no_outliers = df[-which(all_row_identifiers %in% outlier_row_identifiers), ]
  return(no_outliers)
}

removed_outliers = TRUE

if (removed_outliers) {
  # before
  boxplot(measure_total_time_ns ~ opcode, data=measurements[which(measurements$env == 'geth'), ], las=2, outline=TRUE, log='y')
  boxplot(measure_total_time_ns ~ opcode, data=measurements[which(measurements$env == 'evmone'), ], las=2, outline=TRUE, log='y')
  boxplot(measure_total_time_ns ~ opcode, data=measurements[which(measurements$env == 'openethereum'), ], las=2, outline=TRUE, log='y')

  measurements = remove_outliers(measurements, 'measure_total_time_ns')
  
  # after
  boxplot(measure_total_time_ns ~ opcode, data=measurements[which(measurements$env == 'geth'), ], las=2, outline=TRUE, log='y')
  boxplot(measure_total_time_ns ~ opcode, data=measurements[which(measurements$env == 'evmone'), ], las=2, outline=TRUE, log='y')
  boxplot(measure_total_time_ns ~ opcode, data=measurements[which(measurements$env == 'openethereum'), ], las=2, outline=TRUE, log='y')
}
```

```{r}
extract_opcodes <- function(arity) {
  if (!missing(arity)) {
    if (arity == 0) {
      programs = programs[which(is.na(programs$arg0) & is.na(programs$arg1) & is.na(programs$arg2)), ]
    }
    if (arity == 1) {
      programs = programs[which(!is.na(programs$arg0) & is.na(programs$arg1) & is.na(programs$arg2)), ]
    }
    if (arity == 2) {
      programs = programs[which(!is.na(programs$arg1) & is.na(programs$arg2)), ]
    }
    if (arity == 3) {
      programs = programs[which(!is.na(programs$arg2)), ]
    }
  }
  unique(programs$opcode)
}

all_opcodes = extract_opcodes()
nullary_opcodes = extract_opcodes(0)
unary_opcodes = extract_opcodes(1)
binary_opcodes = extract_opcodes(2)
ternary_opcodes = extract_opcodes(3)

all_envs = c('geth', 'evmone', 'openethereum')
```
### Models

Notes:
1. Outliers need to be removed
2. The `argX:op_count` interactions measure the impact on the OPCODE
3. The `argX` are just auxiliary variables added to exclude the effect of cheaper/more expensive PUSHes. We only want to extract the effect of the argument on the measured OPCODE repeated `op_count` times.

```{r}

first_pass = data.frame(matrix(ncol = 8, nrow = 0))
colnames(first_pass) <- c('opcode', 'env', 'has_significant', 'has_impacting', 'estimate_marginal_ns', 'arg0_ns', 'arg1_ns', 'arg2_ns')

# Every `arg` coefficient represents the impact of the argument's byte size growing by 1.
# We treat as impactful the arguments, where:
# 1. The estimate is significant with confidence 0.001
# 2. The increase of arg's byte size by 1 will increase the cost by more than 1%
p_value_thresh = 0.001
impact_ratio = 0.01

arg_lm <- function(df, opcode, env, formula) {
  data = df[which(df$opcode==opcode & df$env==env), ]
  lm(formula, data=data)
}

add_arg_results <- function(model, opcode, env, results_df, arity) {
  stopifnot(arity > 0)

  all_coefficients = summary(model)$coefficients
  arg_coefficients = all_coefficients[!(row.names(all_coefficients) %in% c("op_count", "(Intercept)", "arg0", "arg1", "arg2")),]
  pure_op_count_coeff = all_coefficients["op_count", 1]
  # will be filled if any is impacting
  args_ns = c(NA, NA, NA)
  
  if (arity == 1) {
    # there's only one arg coefficient here, silly R forces us to take a special case path...
    has_significant = arg_coefficients[4] < p_value_thresh
  
    if (has_significant) {
      coefficient_impact = abs(arg_coefficients[1])
      has_impacting = has_significant & coefficient_impact > pure_op_count_coeff * impact_ratio
    } else {
      has_impacting = FALSE
    }
    if (has_impacting) {
      args_ns[1] = arg_coefficients[1]
    }
  } else {
    significant = arg_coefficients[, 4] < p_value_thresh
    has_significant = length(which(significant)) > 0
  
    coefficient_impact = abs(arg_coefficients[, 1])
    can_impact = significant & coefficient_impact > pure_op_count_coeff * impact_ratio
    has_impacting = length(which(can_impact)) > 0
    args_ns[which(can_impact)] = arg_coefficients[which(can_impact), 1]
  }
  results_df[nrow(results_df) + 1, ] = c(opcode, env, has_significant, has_impacting, pure_op_count_coeff, args_ns)
  return(results_df)
}

analyze_for_env <- function(df, results_df, env) {
  for (opcode in unary_opcodes) {
    model = arg_lm(df, opcode, env, measure_total_time_ns ~ op_count + arg0 + arg0:op_count)
    print(c(opcode, env))
    print(summary(model))
    results_df = add_arg_results(model, opcode, env, results_df, 1)
  }
  for (opcode in binary_opcodes) {
    model = arg_lm(df, opcode, env, measure_total_time_ns ~ op_count + arg0 + arg1 + arg0:op_count + arg1:op_count)
    print(c(opcode, env))
    print(summary(model))
    results_df = add_arg_results(model, opcode, env, results_df, 2)
  }
  for (opcode in ternary_opcodes) {
    model = arg_lm(df, opcode, env, measure_total_time_ns ~ op_count + arg0 + arg1 + arg2 + arg0:op_count + arg1:op_count + arg2:op_count)
    print(c(opcode, env))
    print(summary(model))
    results_df = add_arg_results(model, opcode, env, results_df, 3)
  }
  return(results_df)
}

first_pass = analyze_for_env(measurements, first_pass, 'geth')
first_pass = analyze_for_env(measurements, first_pass, 'evmone')
first_pass = analyze_for_env(measurements, first_pass, 'openethereum')

proceed_with_opcodes = unique(first_pass[which(first_pass$has_impacting == 'TRUE'), 'opcode'])

models_with_args = first_pass[which(first_pass$has_impacting == 'TRUE'), c('opcode', 'env')]
```

```{r}
first_pass[which(first_pass$has_impacting == 'TRUE'), ]
```

### Validation of the results

```{r fig.width=15}
validation_plot <- function(df, opcode, env, argcol) {
  par(mfrow=c(5,7))
  for (a in 1:32) {
    by_argcol_data = df[which(df$opcode==opcode & df$env==env & df[, argcol]==a), ]
    if (nrow(by_argcol_data) > 0) {
      boxplot(measure_total_time_ns ~ op_count, data=by_argcol_data)
    } else {
      plot.new()
    }
    title(main=paste(opcode, env, argcol, a, sep=', '))
  }
  par(mfrow=c(1,1))
  boxplot(as.formula(paste('measure_total_time_ns ~ ', argcol, sep='')), data=df[which(df$opcode==opcode & df$env==env & df$op_count==max(df$op_count)), ])
}
```

### Model with all variables ever

Not immediately useful - commented out because it has too many params

```{r}
# mega_model = lm(measure_total_time_ns ~ arg0 + arg1 + env + op_count:env:opcode + arg0:op_count:env:opcode + arg1:op_count:env:opcode, data=measurements[which(measurements$opcode %in% binary_opcodes), ])
# summary(mega_model)
```

### Detailed analysis for selected OPCODEs

```{r}
get_impact_args_for <- function(df, opcode, env) {
  if (opcode %in% nullary_opcodes) {
    return(c())
  }
  args = c()
  for (n in 0:2) {
    argname = paste0('arg', n, '_ns')
    if (!is.na(df[which(df$opcode==opcode & df$env==env), argname])) {
      args = c(n, args)
    }
  }
  return(rev(args))
}

get_args_for <- function(df, opcode, env) {
  if (opcode %in% unary_opcodes) {
    c(0)
  } else if (opcode %in% binary_opcodes) {
    c(0, 1)
  } else if (opcode %in% ternary_opcodes) {
    c(0, 1, 2)
  }
}

get_model_formula_for <- function(df, opcode, env) {
  args = get_args_for(df, opcode, env)
  argnames = paste0('arg', args)
  args_formula = paste0(argnames, collapse=' + ')
  
  impact_args = get_impact_args_for(df, opcode, env)
  if (opcode %in% nullary_opcodes) {
    as.formula('measure_total_time_ns ~ op_count')
  } else if (is.null(impact_args)) {
    as.formula(paste0('measure_total_time_ns ~ op_count +  ', args_formula))
  } else {
  arg_op_count_names = paste0('arg', impact_args, ':op_count')
  arg_op_counts_formula = paste0(arg_op_count_names, collapse=' + ')
    as.formula(paste0('measure_total_time_ns ~ op_count +  ', args_formula, ' + ', arg_op_counts_formula))
  }
}

get_aggregate_formula_for <- function(df, opcode, env) {
  args = get_args_for(df, opcode, env)
  argnames = paste0('arg', args)
  args_formula = paste0(argnames, collapse=' * ')
  as.formula(paste0('measure_total_time_ns ~ op_count * env * opcode * ', args_formula))
}
```

```{r fig.width=15}

plot_model <- function(df, opcode, env, use_mean) {
  if (missing(use_mean)) {
    use_mean = FALSE
  }
  if (use_mean) {
    df = aggregate(get_aggregate_formula_for(df, opcode, env), measurements[which(df$opcode==opcode & df$env==env), ], mean, na.action=na.pass)
  }
  model = arg_lm(df, opcode, env, get_model_formula_for(first_pass, opcode, env))
  print(c(opcode, env))
  print(summary(model))
  
  par(mfrow=c(2,2))
  plot(model)
  
  validation_plot(df, opcode, env, 'arg0')
  if (opcode %in% c(binary_opcodes, ternary_opcodes)) {
    validation_plot(df, opcode, env, 'arg1')
  }
  if (opcode %in% ternary_opcodes) {
    validation_plot(df, opcode, env, 'arg2')
  }
  
  plot_data = df[which(df$env == env & df$opcode == opcode & df$op_count == max(df$op_count)), ]
  if (opcode %in% binary_opcodes) {
    par(mfrow=c(1,1))
    
    decreasing_colors = heat.colors(nrow(plot_data))
    plot_data=plot_data[order(plot_data$measure_total_time_ns, decreasing=TRUE), ]
    with(plot_data, plot(arg0, arg1, col=decreasing_colors, pch=19))
  }
  title(main=paste(opcode, env))
}
```

```{r fig.width=15}
for (env in all_envs) {
  for (opcode in proceed_with_opcodes) {
    plot_model(measurements, opcode, env, use_mean=TRUE)
  } 
}
```

### Producing the final estimates

We'd like to only estimate using the arg-variables in models, where this actually matters to avoid spurious impact of insignificant variables.

We'll estimate a model with only those argument variables, where they turned out impacting.
For those were no argument variable was impacting, we'll only estimate the marginal increase (corresponding to the constant cost of an OPCODE).

```{r}
add_non_arg_model_estimates <- function(model, results_df, env, opcode) {
  pure_op_count_coeff = summary(model)$coefficients["op_count", 1]
  args_ns = c(NA, NA, NA)
  results_df[nrow(results_df) + 1, ] = c(opcode, env, FALSE, FALSE, pure_op_count_coeff, args_ns)
  return(results_df)
}
add_arg_model_estimates <- function(model, opcode, env, results_df, df) {
  all_coefficients = summary(model)$coefficients
  arg_coefficients = all_coefficients[!(row.names(all_coefficients) %in% c("op_count", "(Intercept)", "arg0", "arg1", "arg2")),]
  pure_op_count_coeff = all_coefficients["op_count", 1]
  # will be filled if any is impacting
  args_ns = c(NA, NA, NA)
  
  impact_args = get_impact_args_for(df, opcode, env)
  arg_op_count_names = paste0('op_count:arg', impact_args)

  args_ns[impact_args + 1] = all_coefficients[arg_op_count_names, 'Estimate']
  results_df[nrow(results_df) + 1, ] = c(opcode, env, TRUE, TRUE, pure_op_count_coeff, args_ns)
  return(results_df)
}
```

```{r}
estimates = data.frame(matrix(ncol = ncol(first_pass), nrow = 0))
colnames(estimates) <- colnames(first_pass)

for (env in all_envs) {
  for (opcode in all_opcodes) {
    is_modeled_with_args = !is.null(get_impact_args_for(first_pass, opcode, env))
    model = arg_lm(measurements, opcode, env, get_model_formula_for(first_pass, opcode, env))
    print(c(opcode, env))
    print(summary(model))
    if (is_modeled_with_args) {
      estimates = add_arg_model_estimates(model, opcode, env, estimates, first_pass)
    } else {
      estimates = add_non_arg_model_estimates(model, estimates, env, opcode)
    }
  }
}
```

```{r}
setwd("~/sources/imapp/gas-cost-estimator/src")
write.csv(estimates, "../../local/argument_estimated_cost.csv", quote=FALSE, row.names=FALSE)
```

