---
title: "R Notebook: estimation of impact of arguments on gas costs; for Gas Cost Estimator"
output: html_notebook
---

```{r include=FALSE, fig.width=20}
library(sqldf)
library(nlme)

# prevent scientific notation
options(scipen = 100)
```


## Data preparations

Read in the `programs.csv` as generated by `src/pg_arguments` with `--fullCSV` flag on:
```{r fig.width=20}
setwd("~/sources/imapp/gas-cost-estimator/src")

program_set_codename = "arithmetic_c50_opc10"
programs = read.csv(paste("../../local/pg_arguments_", program_set_codename, ".csv", sep=""))
```

Unfortunately `JUMP` and `JUMPI` are currently broken in `geth` (they require a `JUMPDEST`).
Because they work in `evmone` (it prepends `JUMPDEST`) forcefully, we should drop them from the analysis.
Also `RETURNDATACOPY` program generation is broken in general (`return data out of bounds`).

```{r fig.width=20}
clean_programs = function(programs) {
  programs = programs[which(programs$opcode != "JUMP"), ]
  programs = programs[which(programs$opcode != "JUMPI"), ]
  programs = programs[which(programs$opcode != "RETURNDATACOPY"), ]
  
  # necessary to get rid of the factor levels which we just filtered out
  droplevels(programs)
}

programs = clean_programs(programs)

head(programs)
```

Read in the `result_*.csv` as generated by `src/measurements.py`. 

Invocation similar to: `sudo docker run   --rm   --privileged --security-opt seccomp:unconfined -v /home/ubuntu/pdobacz/local:/srv/local  -it gas-cost-estimator/evmone_total sh -c "cd src && cat /srv/local/pg_arguments_arithmetic_c50_opc10.csv | python3 instrumentation_measurement/measurements.py measure --evm evmone --mode total --sampleSize=50 --nSamples=4 > /srv/local/evmone_pg_arguments_arithmetic_c50_opc10_50_4.csv"`. 

```{r fig.width=20}
setwd("~/sources/imapp/gas-cost-estimator/src")

load_data_set <- function(env, program_set_codename, measurement_codename) {
  setwd("~/sources/imapp/gas-cost-estimator/src")
  data_set_codename = paste(program_set_codename, "_", measurement_codename, sep="")
  filepath = paste("../../local/", env, "_pg_arguments_", data_set_codename, ".csv", sep="")
  result = read.csv(filepath)
  result$env = env
  return(result)
}
result_geth = load_data_set("geth", program_set_codename, "50_4")
result_evmone = load_data_set("evmone", program_set_codename, "50_4")
results = rbind(result_evmone, result_geth)
head(results)
```

```{r fig.width=20}
measurements = sqldf("SELECT opcode, op_count, arg0, arg1, arg2, sample_id, run_id, measure_total_time_ns, env, results.program_id
                     FROM results
                     INNER JOIN
                       programs ON(results.program_id = programs.program_id)
                     ")
head(measurements)
```
```{r}
remove_outliers <- function(df, col) {
  boxplot_result = boxplot(df[, col] ~ df[, 'op_count'] + df[, 'env'] + df[, 'opcode'], plot=FALSE)
  outliers = boxplot_result$out
  names = boxplot_result$names[boxplot_result$group]
  all_row_identifiers = paste(df[, col], df[, 'op_count'], df[, 'env'], df[, 'opcode'], sep='.')
  outlier_row_identifiers = paste(outliers, names, sep='.')
  no_outliers = df[-which(all_row_identifiers %in% outlier_row_identifiers), ]
  return(no_outliers)
}

removed_outliers = TRUE

if (removed_outliers) {
  # before
  boxplot(measure_total_time_ns ~ opcode, data=measurements[which(measurements$env == 'geth'), ], las=2, outline=TRUE, log='y')
  boxplot(measure_total_time_ns ~ opcode, data=measurements[which(measurements$env == 'evmone'), ], las=2, outline=TRUE, log='y')

  measurements = remove_outliers(measurements, 'measure_total_time_ns')
  
  # after
  boxplot(measure_total_time_ns ~ opcode, data=measurements[which(measurements$env == 'geth'), ], las=2, outline=TRUE, log='y')
  boxplot(measure_total_time_ns ~ opcode, data=measurements[which(measurements$env == 'evmone'), ], las=2, outline=TRUE, log='y')
}
```

```{r}
extract_opcodes <- function(program_set_codename, arity) {
  setwd("~/sources/imapp/gas-cost-estimator/src")
  programs = read.csv(paste("../../local/pg_arguments_", program_set_codename, ".csv", sep=""))
  programs = clean_programs(programs)
  if (!missing(arity)) {
    if (arity == 1) {
      programs = programs[which(is.na(programs$arg1) & is.na(programs$arg2)), ]
    }
    if (arity == 2) {
      programs = programs[which(!is.na(programs$arg1) & is.na(programs$arg2)), ]
    }
    if (arity == 3) {
      programs = programs[which(!is.na(programs$arg1) & !is.na(programs$arg2)), ]
    }
  }
  unique(programs$opcode)
}

all_opcodes = extract_opcodes(program_set_codename)
unary_opcodes = extract_opcodes(program_set_codename, 1)
binary_opcodes = extract_opcodes(program_set_codename, 2)
ternary_opcodes = extract_opcodes(program_set_codename, 3)
```
### Models

Notes:
1. Outliers need to be removed
2. The `argX:op_count` interactions measure the impact on the OPCODE
3. The `argX` are just auxiliary variables added to exclude the effect of cheaper/more expensive PUSHes. We only want to extract the effect of the argument on the measured OPCODE repeated `op_count` times.

```{r}

first_pass = data.frame(matrix(ncol = 8, nrow = 0))
colnames(first_pass) <- c('opcode', 'env', 'has_significant', 'has_impacting', 'estimate_marginal_ns', 'arg0_ns', 'arg1_ns', 'arg2_ns')

# Every `arg` coefficient represents the impact of the argument's byte size growing by 1.
# We treat as impactful the arguments, where:
# 1. The estimate is significant with confidence 0.1
# 2. The increase of arg's byte size by 1 will increase the cost by more than 5%
impact_ratio = 0.05
p_value_thresh = 0.1

arg_lm <- function(df, opcode, env, formula) {
  data = df[which(df$opcode==opcode & df$env==env), ]
  lm(formula, data=data)
}

add_arg_results <- function(model, opcode, env, results_df, arity) {
  all_coefficients = summary(model)$coefficients
  arg_coefficients = all_coefficients[!(row.names(all_coefficients) %in% c("op_count", "(Intercept)", "arg0", "arg1", "arg2")),]
  pure_op_count_coeff = all_coefficients["op_count", 1]
  # will be filled if any is impacting
  args_ns = c(NA, NA, NA)
    
  if (arity == 1) {
    # there's only one arg coefficient here, silly R forces us to take a special case path...
    has_significant = arg_coefficients[4] < p_value_thresh
  
    if (has_significant) {
      coefficient_impact = abs(arg_coefficients[1])
      has_impacting = has_significant & coefficient_impact > pure_op_count_coeff * impact_ratio
    } else {
      has_impacting = FALSE
    }
    if (has_impacting) {
      args_ns[1] = arg_coefficients[1]
    }
  } else {
    significant = arg_coefficients[, 4] < p_value_thresh
    has_significant = length(which(significant)) > 0
  
    coefficient_impact = abs(arg_coefficients[, 1])
    can_impact = significant & coefficient_impact > pure_op_count_coeff * impact_ratio
    has_impacting = length(which(can_impact)) > 0
    args_ns[which(can_impact)] = arg_coefficients[which(can_impact), 1]
  }
  results_df[nrow(results_df) + 1, ] = c(opcode, env, has_significant, has_impacting, pure_op_count_coeff, args_ns)
  return(results_df)
}

analyze_for_env <- function(df, results_df, env) {
  for (opcode in unary_opcodes) {
    model = arg_lm(df, opcode, env, measure_total_time_ns ~ op_count + arg0 + arg0:op_count)
    print(c(opcode, env))
    print(summary(model))
    results_df = add_arg_results(model, opcode, env, results_df, 1)
  }
  for (opcode in binary_opcodes) {
    model = arg_lm(df, opcode, env, measure_total_time_ns ~ op_count + arg0 + arg1 + arg0:op_count + arg1:op_count)
    print(c(opcode, env))
    print(summary(model))
    results_df = add_arg_results(model, opcode, env, results_df, 2)
  }
  for (opcode in ternary_opcodes) {
    model = arg_lm(df, opcode, env, measure_total_time_ns ~ op_count + arg0 + arg1 + arg2 + arg0:op_count + arg1:op_count + arg2:op_count)
    print(c(opcode, env))
    print(summary(model))
    results_df = add_arg_results(model, opcode, env, results_df, 3)
  }
  return(results_df)
}

first_pass = analyze_for_env(measurements, first_pass, 'geth')
first_pass = analyze_for_env(measurements, first_pass, 'evmone')

proceed_with_opcodes = unique(first_pass[which(first_pass$has_impacting == 'TRUE'), 'opcode'])

models_with_args = first_pass[which(first_pass$has_impacting == 'TRUE'), c('opcode', 'env')]
```

```{r}
first_pass[which(first_pass$has_impacting == 'TRUE'), ]
```

### Model with all variables ever

Not immediately useful - commented out because it has too many params

```{r}
# mega_model = lm(measure_total_time_ns ~ arg0 + arg1 + env + op_count:env:opcode + arg0:op_count:env:opcode + arg1:op_count:env:opcode, data=measurements[which(measurements$opcode %in% binary_opcodes), ])
# summary(mega_model)
```

### Detailed analysis for selected OPCODEs

```{r}
# if other than binary OPCODEs end up being selected we must expand the code
stopifnot(proceed_with_opcodes %in% binary_opcodes)
measurements_mean = aggregate(measure_total_time_ns ~ op_count * env * opcode * arg0 * arg1, measurements[which(measurements$opcode %in% proceed_with_opcodes), ], mean, na.action=na.pass)

plot_model <- function(df, opcode, env) {
  model = arg_lm(df, opcode, env, measure_total_time_ns ~ op_count + arg0 + arg1 + arg0:op_count + arg1:op_count)
  print(c(opcode, env))
  print(summary(model))
  
  par(mfrow=c(2,2))
  plot(model)
  
  plot_data = df[which(df$env == env & df$opcode == opcode & df$op_count != 0), ]
  par(mfrow=c(1,1))
  boxplot(measure_total_time_ns ~ arg0, data=plot_data, las=2, outline=removed_outliers)
  boxplot(measure_total_time_ns ~ arg1, data=plot_data, las=2, outline=removed_outliers)
  
  plot_data=plot_data[order(plot_data$arg0, plot_data$arg1), ]
  decreasing_colors = heat.colors(nrow(plot_data))
  plot_data=plot_data[order(plot_data$measure_total_time_ns, decreasing=TRUE), ]
  with(plot_data, plot(arg0, arg1, col=decreasing_colors, pch=19))
  title(main=paste(opcode, env))
}
for (opcode in proceed_with_opcodes) {
  plot_model(measurements_mean, opcode, 'geth')
} 
for (opcode in proceed_with_opcodes) {
  plot_model(measurements_mean, opcode, 'evmone')
}
```

### Producing the final estimates

We'd like to only estimate using the arg-variables in models, where this actually matters to avoid spurious impact of insignificant variables.

We'll estimate a model with only those argument variables, where they turned out impacting.
For those were no argument variable was impacting, we'll only estimate the marginal increase (corresponding to the constant cost of an OPCODE).

```{r}
make_non_arg_model <- function(model, results_df, env, opcode) {
  print(c(opcode, env))
  print(summary(model))
  pure_op_count_coeff = summary(model)$coefficients["op_count", 1]
  args_ns = c(NA, NA, NA)
  results_df[nrow(results_df) + 1, ] = c(opcode, env, FALSE, FALSE, pure_op_count_coeff, args_ns)
  return(results_df)
}
add_arg_model_estimates <- function(model, opcode, env, results_df, arg_variables, arg_names) {
  all_coefficients = summary(model)$coefficients
  arg_coefficients = all_coefficients[!(row.names(all_coefficients) %in% c("op_count", "(Intercept)", "arg0", "arg1", "arg2")),]
  pure_op_count_coeff = all_coefficients["op_count", 1]
  # will be filled if any is impacting
  args_ns = c(NA, NA, NA)
  args_ns[arg_variables] = all_coefficients[arg_names, 'Estimate']
  results_df[nrow(results_df) + 1, ] = c(opcode, env, TRUE, TRUE, pure_op_count_coeff, args_ns)
  return(results_df)
}
```

```{r}
estimates = data.frame(matrix(ncol = ncol(first_pass), nrow = 0))
colnames(estimates) <- colnames(first_pass)

for (env in c('evmone', 'geth')) {
  for (opcode in unary_opcodes) {
    row_to_find <- data.frame(opcode=opcode, env=env)
    is_modeled_with_args = duplicated(rbind(models_with_args, row_to_find))[nrow(models_with_args)+1]
    if (!is_modeled_with_args) {
      model = arg_lm(measurements, opcode, env, measure_total_time_ns ~ op_count + arg0)
      estimates = make_non_arg_model(model, estimates, env, opcode)
    }
  }
  for (opcode in binary_opcodes) {
    row_to_find <- data.frame(opcode=opcode, env=env)
    is_modeled_with_args = duplicated(rbind(models_with_args, row_to_find))[nrow(models_with_args)+1]
    if (!is_modeled_with_args) {
      model = arg_lm(measurements, opcode, env, measure_total_time_ns ~ op_count + arg0 + arg1)
      estimates = make_non_arg_model(model, estimates, env, opcode)
    }
  }
  for (opcode in ternary_opcodes) {
    row_to_find <- data.frame(opcode=opcode, env=env)
    is_modeled_with_args = duplicated(rbind(models_with_args, row_to_find))[nrow(models_with_args)+1]
    if (!is_modeled_with_args) {
      model = arg_lm(measurements, opcode, env, measure_total_time_ns ~ op_count + arg0 + arg1 + arg2)
      estimates = make_non_arg_model(model, estimates, env, opcode)
    }
  }
}

# TODO: when changing this, refactor the selectors of variables, this is very error prone
opcode = 'EXP'
env = 'evmone'
model = arg_lm(measurements, opcode, env, measure_total_time_ns ~ op_count + arg0 + arg1 + op_count:arg1)
print(c(opcode, env))
print(summary(model))
estimates = add_arg_model_estimates(model, opcode, env, estimates, c(2), c('op_count:arg1'))

opcode = 'EXP'
env = 'geth'
model = arg_lm(measurements, opcode, env, measure_total_time_ns ~ op_count + arg0 + arg1 + op_count:arg1)
print(c(opcode, env))
print(summary(model))
estimates = add_arg_model_estimates(model, opcode, env, estimates, c(2), c('op_count:arg1'))

opcode = 'MOD'
env = 'geth'
model = arg_lm(measurements, opcode, env, measure_total_time_ns ~ op_count + arg0 + arg1 + op_count:arg0 + op_count:arg1)
print(c(opcode, env))
print(summary(model))
estimates = add_arg_model_estimates(model, opcode, env, estimates, c(1, 2), c('op_count:arg0', 'op_count:arg1'))

opcode = 'DIV'
env = 'geth'
model = arg_lm(measurements, opcode, env, measure_total_time_ns ~ op_count + arg0 + arg1 + op_count:arg0)
print(c(opcode, env))
print(summary(model))
estimates = add_arg_model_estimates(model, opcode, env, estimates, c(1), c('op_count:arg0'))

opcode = 'SDIV'
env = 'geth'
model = arg_lm(measurements, opcode, env, measure_total_time_ns ~ op_count + arg0 + arg1 + op_count:arg0)
print(c(opcode, env))
print(summary(model))
estimates = add_arg_model_estimates(model, opcode, env, estimates, c(1), c('op_count:arg0'))

opcode = 'SMOD'
env = 'geth'
model = arg_lm(measurements, opcode, env, measure_total_time_ns ~ op_count + arg0 + arg1 + op_count:arg0)
print(c(opcode, env))
print(summary(model))
estimates = add_arg_model_estimates(model, opcode, env, estimates, c(1), c('op_count:arg0'))

```

```{r}
setwd("~/sources/imapp/gas-cost-estimator/src")
write.csv(estimates, "../../local/argument_estimated_cost.csv", quote=FALSE, row.names=FALSE)
```

