---
title: "R Notebook: estimation of impact of arguments on gas costs; for Gas Cost Estimator"
output: html_notebook
---

```{r include=FALSE, fig.width=20}
library(sqldf)
library(nlme)
```


## Data preparations

Read in the `programs.csv` as generated by `src/pg_arguments` with `--fullCSV` flag on:
```{r fig.width=20}
setwd("~/sources/imapp/gas-cost-estimator/src")

program_set_codename = "arithmetic_c50_opc10"
programs = read.csv(paste("../../local/pg_arguments_", program_set_codename, ".csv", sep=""))
```

Unfortunately `JUMP` and `JUMPI` are currently broken in `geth` (they require a `JUMPDEST`).
Because they work in `evmone` (it prepends `JUMPDEST`) forcefully, we should drop them from the analysis.
Also `RETURNDATACOPY` program generation is broken in general (`return data out of bounds`).

```{r fig.width=20}
clean_programs = function(programs) {
  programs = programs[which(programs$opcode != "JUMP"), ]
  programs = programs[which(programs$opcode != "JUMPI"), ]
  programs = programs[which(programs$opcode != "RETURNDATACOPY"), ]
  
  # necessary to get rid of the factor levels which we just filtered out
  droplevels(programs)
}

programs = clean_programs(programs)

head(programs)
```

Read in the `result_*.csv` as generated by `src/measurements.py`. 

Invocation similar to: `sudo docker run   --rm   --privileged --security-opt seccomp:unconfined -v /home/ubuntu/pdobacz/local:/srv/local  -it gas-cost-estimator/evmone_total sh -c "cd src && cat /srv/local/pg_arguments_arithmetic_c50_opc10.csv | python3 instrumentation_measurement/measurements.py measure --evm evmone --mode total --sampleSize=50 --nSamples=4 > /srv/local/evmone_pg_arguments_arithmetic_c50_opc10_50_4.csv"`. 

```{r fig.width=20}
setwd("~/sources/imapp/gas-cost-estimator/src")

load_data_set <- function(env, program_set_codename, measurement_codename) {
  setwd("~/sources/imapp/gas-cost-estimator/src")
  data_set_codename = paste(program_set_codename, "_", measurement_codename, sep="")
  filepath = paste("../../local/", env, "_pg_arguments_", data_set_codename, ".csv", sep="")
  result = read.csv(filepath)
  result$env = env
  return(result)
}
#result_geth = load_data_set("geth", "exp", "50_4")
result_evmone = load_data_set("evmone", program_set_codename, "50_4")
results = rbind(result_evmone)#, result_geth)
head(results)
```

```{r fig.width=20}
measurements = sqldf("SELECT opcode, op_count, arg1, arg2, arg3, sample_id, run_id, measure_total_time_ns, env, results.program_id
                     FROM results
                     INNER JOIN
                       programs ON(results.program_id = programs.program_id)
                     ")
head(measurements)
```

```{r}

extract_opcodes <- function(program_set_codename, arity) {
  setwd("~/sources/imapp/gas-cost-estimator/src")
  programs = read.csv(paste("../../local/pg_arguments_", program_set_codename, ".csv", sep=""))
  programs = clean_programs(programs)
  if (!missing(arity)) {
    if (arity == 1) {
      programs = programs[which(is.na(programs$arg2) & is.na(programs$arg3)), ]
    }
    if (arity == 2) {
      programs = programs[which(!is.na(programs$arg2) & is.na(programs$arg3)), ]
    }
    if (arity == 3) {
      programs = programs[which(!is.na(programs$arg2) & !is.na(programs$arg3)), ]
    }
  }
  unique(programs$opcode)
}

all_opcodes = extract_opcodes(program_set_codename)
unary_opcodes = extract_opcodes(program_set_codename, 1)
binary_opcodes = extract_opcodes(program_set_codename, 2)
ternary_opcodes = extract_opcodes(program_set_codename, 3)
```

```{r}

first_pass = data.frame(matrix(ncol = 3, nrow = 0))
colnames(first_pass) <- c('opcode', 'has_significant', 'has_impacting')
for (opcode in unary_opcodes) {
  model = lm(measure_total_time_ns ~ arg1:op_count, data=measurements[which(measurements$opcode==opcode), ])
  print(opcode)
  print(summary(model))
  significant = which(summary(model)$coefficients[-1, 4] < 0.01)
  has_significant = length(significant) > 0

  # THIS IS NOT GOOD! intercept contains all the pushes and pops, so comparing to that makes no sense
  intercept = summary(model)$coefficients[1, 1]
  significant_coefficients = summary(model)$coefficients[significant + 1, 1]
  coefficient_impact = abs(significant_coefficients) * 32
  can_impact = which(coefficient_impact > intercept * 0.1)
  has_impacting = length(can_impact) > 0
  first_pass[nrow(first_pass) + 1, ] = c(opcode, has_significant, has_impacting)
}
for (opcode in binary_opcodes) {
  model = lm(measure_total_time_ns ~ arg1:op_count + arg2:op_count, data=measurements[which(measurements$opcode==opcode), ])
  print(opcode)
  print(summary(model))
  significant = which(summary(model)$coefficients[-1, 4] < 0.01)
  has_significant = length(significant) > 0

  intercept = summary(model)$coefficients[1, 1]
  significant_coefficients = summary(model)$coefficients[significant + 1, 1]
  coefficient_impact = abs(significant_coefficients) * 32
  can_impact = which(coefficient_impact > intercept * 0.1)
  has_impacting = length(can_impact) > 0
  first_pass[nrow(first_pass) + 1, ] = c(opcode, has_significant, has_impacting)
}
for (opcode in ternary_opcodes) {
  model = lm(measure_total_time_ns ~ arg1:op_count + arg2:op_count + arg3:op_count, data=measurements[which(measurements$opcode==opcode), ])
  print(opcode)
  print(summary(model))
  significant = which(summary(model)$coefficients[-1, 4] < 0.01)
  has_significant = length(significant) > 0

  intercept = summary(model)$coefficients[1, 1]
  significant_coefficients = summary(model)$coefficients[significant + 1, 1]
  coefficient_impact = abs(significant_coefficients) * 32
  can_impact = which(coefficient_impact > intercept * 0.1)
  has_impacting = length(can_impact) > 0
  first_pass[nrow(first_pass) + 1, ] = c(opcode, has_significant, has_impacting)
}

first_pass[which(first_pass$has_impacting == 'TRUE'), 'opcode']
```

