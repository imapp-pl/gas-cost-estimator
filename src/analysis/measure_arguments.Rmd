---
title: "R Notebook: estimation of impact of arguments on gas costs; for Gas Cost Estimator"
output: html_notebook
---

```{r include=FALSE, fig.width=20}
library(sqldf)
library(nlme)

# prevent scientific notation
options(scipen = 100)
```


## Data preparations

Read in the `programs.csv` as generated by `src/pg_arguments` with `--fullCSV` flag on:
```{r fig.width=20}
setwd("~/sources/imapp/gas-cost-estimator/src")

program_set_codename = "arithmetic_c50_opc10"
programs = read.csv(paste("../../local/pg_arguments_", program_set_codename, ".csv", sep=""))
```

Unfortunately `JUMP` and `JUMPI` are currently broken in `geth` (they require a `JUMPDEST`).
Because they work in `evmone` (it prepends `JUMPDEST`) forcefully, we should drop them from the analysis.
Also `RETURNDATACOPY` program generation is broken in general (`return data out of bounds`).

```{r fig.width=20}
clean_programs = function(programs) {
  programs = programs[which(programs$opcode != "JUMP"), ]
  programs = programs[which(programs$opcode != "JUMPI"), ]
  programs = programs[which(programs$opcode != "RETURNDATACOPY"), ]
  
  # necessary to get rid of the factor levels which we just filtered out
  droplevels(programs)
}

programs = clean_programs(programs)

head(programs)
```

Read in the `result_*.csv` as generated by `src/measurements.py`. 

Invocation similar to: `sudo docker run   --rm   --privileged --security-opt seccomp:unconfined -v /home/ubuntu/pdobacz/local:/srv/local  -it gas-cost-estimator/evmone_total sh -c "cd src && cat /srv/local/pg_arguments_arithmetic_c50_opc10.csv | python3 instrumentation_measurement/measurements.py measure --evm evmone --mode total --sampleSize=50 --nSamples=4 > /srv/local/evmone_pg_arguments_arithmetic_c50_opc10_50_4.csv"`. 

```{r fig.width=20}
setwd("~/sources/imapp/gas-cost-estimator/src")

load_data_set <- function(env, program_set_codename, measurement_codename) {
  setwd("~/sources/imapp/gas-cost-estimator/src")
  data_set_codename = paste(program_set_codename, "_", measurement_codename, sep="")
  filepath = paste("../../local/", env, "_pg_arguments_", data_set_codename, ".csv", sep="")
  result = read.csv(filepath)
  result$env = env
  return(result)
}
result_geth = load_data_set("geth", program_set_codename, "50_4")
result_evmone = load_data_set("evmone", program_set_codename, "50_4")
results = rbind(result_evmone, result_geth)
head(results)
```

```{r fig.width=20}
measurements = sqldf("SELECT opcode, op_count, arg1, arg2, arg3, sample_id, run_id, measure_total_time_ns, env, results.program_id
                     FROM results
                     INNER JOIN
                       programs ON(results.program_id = programs.program_id)
                     ")
head(measurements)
```
```{r}
remove_outliers <- function(df, col) {
  outliers = boxplot(df[, col] ~ df[, 'op_count'] + df[, 'env'] + df[, 'opcode'], plot=FALSE)$out
  no_outliers = df[-which(df[, col] %in% outliers), ]
  return(no_outliers)
}

removed_outliers = TRUE

if (removed_outliers) {
  measurements = remove_outliers(measurements, 'measure_total_time_ns')
}
```

```{r}
extract_opcodes <- function(program_set_codename, arity) {
  setwd("~/sources/imapp/gas-cost-estimator/src")
  programs = read.csv(paste("../../local/pg_arguments_", program_set_codename, ".csv", sep=""))
  programs = clean_programs(programs)
  if (!missing(arity)) {
    if (arity == 1) {
      programs = programs[which(is.na(programs$arg2) & is.na(programs$arg3)), ]
    }
    if (arity == 2) {
      programs = programs[which(!is.na(programs$arg2) & is.na(programs$arg3)), ]
    }
    if (arity == 3) {
      programs = programs[which(!is.na(programs$arg2) & !is.na(programs$arg3)), ]
    }
  }
  unique(programs$opcode)
}

all_opcodes = extract_opcodes(program_set_codename)
unary_opcodes = extract_opcodes(program_set_codename, 1)
binary_opcodes = extract_opcodes(program_set_codename, 2)
ternary_opcodes = extract_opcodes(program_set_codename, 3)
```
### Models

Notes:
1. Outliers need to be removed
2. The `argX:op_count` interactions measure the impact on the OPCODE
3. The `argX` are just auxiliary variables added to exclude the effect of cheaper/more expensive PUSHes. We only want to extract the effect of the argument on the measured OPCODE repeated `op_count` times.

```{r}

first_pass = data.frame(matrix(ncol = 8, nrow = 0))
colnames(first_pass) <- c('opcode', 'env', 'has_significant', 'has_impacting', 'estimate_ns', 'arg1_ns', 'arg2_ns', 'arg3_ns')

# Every `arg` coefficient represents the impact of the argument's byte size growing by 1.
# We treat as impactful the arguments, where:
# 1. The estimate is significant with confidence 0.1
# 2. The increase of arg's byte size by 1 will increase the cost by more than 5%
impact_ratio = 0.05
p_value_thresh = 0.1

arg_lm <- function(df, opcode, env, arity) {
  data = df[which(df$opcode==opcode & df$env==env), ]
  if (arity == 1) {
    lm(measure_total_time_ns ~ op_count + arg1 + arg1:op_count, data=data)
  } else if (arity == 2) {
    lm(measure_total_time_ns ~ op_count + arg1 + arg2 + arg1:op_count + arg2:op_count, data=data)
  } else if (arity == 3) {
    lm(measure_total_time_ns ~ op_count + arg1 + arg2 + arg3 + arg1:op_count + arg2:op_count + arg3:op_count, data=data)
  }
}

add_arg_results <- function(model, opcode, env, results_df, arity) {
  all_coefficients = summary(model)$coefficients
  arg_coefficients = all_coefficients[!(row.names(all_coefficients) %in% c("op_count", "(Intercept)", "arg1", "arg2", "arg3")),]
  pure_op_count_coeff = all_coefficients["op_count", 1]
  # will be filled if any is impacting
  args_ns = c(NA, NA, NA)
    
  if (arity == 1) {
    # there's only one arg coefficient here, silly R forces us to take a special case path...
    has_significant = arg_coefficients[4] < p_value_thresh
  
    if (has_significant) {
      coefficient_impact = abs(arg_coefficients[1])
      has_impacting = has_significant & coefficient_impact > pure_op_count_coeff * impact_ratio
    } else {
      has_impacting = FALSE
    }
    if (has_impacting) {
      args_ns[1] = arg_coefficients[1]
    }
  } else {
    significant = arg_coefficients[, 4] < p_value_thresh
    has_significant = length(which(significant)) > 0
  
    coefficient_impact = abs(arg_coefficients[, 1])
    can_impact = significant & coefficient_impact > pure_op_count_coeff * impact_ratio
    has_impacting = length(which(can_impact)) > 0
    args_ns[which(can_impact)] = arg_coefficients[which(can_impact), 1]
  }
  results_df[nrow(results_df) + 1, ] = c(opcode, env, has_significant, has_impacting, pure_op_count_coeff, args_ns)
  return(results_df)
}

analyze_for_env <- function(df, results_df, env) {
  for (opcode in unary_opcodes) {
    model = arg_lm(df, opcode, env, 1)
    print(c(opcode, env))
    print(summary(model))
    results_df = add_arg_results(model, opcode, env, results_df, 1)
  }
  for (opcode in binary_opcodes) {
    model = arg_lm(df, opcode, env, 2)
    print(c(opcode, env))
    print(summary(model))
    results_df = add_arg_results(model, opcode, env, results_df, 2)
  }
  for (opcode in ternary_opcodes) {
    model = arg_lm(df, opcode, env, 3)
    print(c(opcode, env))
    print(summary(model))
    results_df = add_arg_results(model, opcode, env, results_df, 3)
  }
  return(results_df)
}

first_pass = analyze_for_env(measurements, first_pass, 'geth')
first_pass = analyze_for_env(measurements, first_pass, 'evmone')

proceed_with_opcodes = unique(first_pass[which(first_pass$has_impacting == 'TRUE'), 'opcode'])

first_pass[which(first_pass$has_impacting == 'TRUE'), ]
```

### Model with all variables ever

Not immediately useful - commented out because it has too many params

```{r}
# mega_model = lm(measure_total_time_ns ~ arg1 + arg2 + env + op_count:env:opcode + arg1:op_count:env:opcode + arg2:op_count:env:opcode, data=measurements[which(measurements$opcode %in% binary_opcodes), ])
# summary(mega_model)
```

### Detailed analysis for selected OPCODEs

```{r}
# if other than binary OPCODEs end up being selected we must expand the code
stopifnot(proceed_with_opcodes %in% binary_opcodes)
measurements_mean = aggregate(measure_total_time_ns ~ op_count * env * opcode * arg1 * arg2, measurements[which(measurements$opcode %in% proceed_with_opcodes), ], mean, na.action=na.pass)
env = 'evmone'
plot_model <- function(df, opcode, env) {
  model = arg_lm(df, opcode, env, 2)
  print(c(opcode, env))
  print(summary(model))
  
  par(mfrow=c(2,2))
  plot(model)
  
  plot_data = df[which(df$env == env & df$opcode == opcode & df$op_count != 0), ]
  par(mfrow=c(1,1))
  boxplot(measure_total_time_ns ~ arg1, data=plot_data, las=2, outline=removed_outliers)
  boxplot(measure_total_time_ns ~ arg2, data=plot_data, las=2, outline=removed_outliers)
  
  plot_data=plot_data[order(plot_data$arg1, plot_data$arg2), ]
  decreasing_colors = heat.colors(nrow(plot_data))
  plot_data=plot_data[order(plot_data$measure_total_time_ns, decreasing=TRUE), ]
  with(plot_data, plot(arg1, arg2, col=decreasing_colors, pch=19))
  title(main=paste(opcode, env))
}
for (opcode in proceed_with_opcodes) {
  plot_model(measurements_mean, opcode, 'geth')
} 
for (opcode in proceed_with_opcodes) {
  plot_model(measurements_mean, opcode, 'evmone')
}
```

### Producing the final estimates

```{r}

```

