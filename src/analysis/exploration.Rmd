---
title: "R Notebook: initial exploration for Gas Cost Estimator"
output: html_notebook
---

```{r fig.width=20}
library(sqldf)
```

<!---
This style tag is for `<div class="superbigimage">` to have a horizontal scrollbar in the HTML output
use:
<div class="superbigimage">
plot
</div>
source: https://stackoverflow.com/questions/52448104/how-to-add-horizontal-scroll-bar-for-a-ggplot-plot-in-rmarkdown-html
-->
<style>
  .superbigimage{
      overflow-x:scroll;
      white-space: nowrap;
  }
  .superbigimage img{
     max-width: none;
  }
</style>

Read in the `programs.csv` as generated by `src/program_generator.py` with `--fullCSV` flag on
```{r fig.width=20}
setwd("~/sources/imapp/gas-cost-estimator/src")
programs = read.csv("../../programs.csv")
```
Unfortunately `JUMP` and `JUMPI` are currently broken in `geth` (they require a `JUMPDEST`). Because they work in `evmone` (it prepends `JUMPDEST`) forcefully, we should drop them from the analisys. **TODO** fix this somehow.
Also `RETURNDATACOPY` program generation is broken in general (`return data out of bounds`):
```{r fig.width=20}
programs = programs[which(programs$opcode_measured != "JUMP"), ]
programs = programs[which(programs$opcode_measured != "JUMPI"), ]
programs = programs[which(programs$opcode_measured != "RETURNDATACOPY"), ]
head(programs)
```

Modify `programs.csv` to adjust for the fact, that `evmone` prepends a `JUMPDEST` instruction at the vary beginning of each bytecode:
(**TODO** track and adjust for the programs instructions more elegantly)

```{r fig.width=20}
programs$measured_op_position_evmone = programs$measured_op_position + 1
head(programs)
```

Read in the `result_geth.csv` and `result_evmone.csv` as generated by `src/measurements.py`

```{r fig.width=20}
setwd("~/sources/imapp/gas-cost-estimator/src")
result_geth = read.csv("../../result_geth.csv")
result_evmone = read.csv("../../result_evmone.csv")
result_openethereum = read.csv("../../result_openethereum.csv")
result_geth$env = "geth"
result_evmone$env = "evmone"
result_openethereum$env = "openethereum"
results = rbind(result_geth, result_evmone, result_openethereum)
head(results)
```

Combine the two tables to see only times of the measured opcodes.

```{r fig.width=20}
measurements = sqldf("SELECT opcode_measured, sample_id, run_id, measure_all_time_ns, env
                     FROM results
                     INNER JOIN 
                       programs ON(results.program_id = programs.program_id)
                     WHERE 
                       (results.instruction_id = programs.measured_op_position AND results.env = 'geth') OR
                       (results.instruction_id = programs.measured_op_position_evmone AND results.env = 'evmone') OR
                       (results.instruction_id = programs.measured_op_position AND results.env = 'openethereum')
                     ")

head(measurements)
```

Let's also adjust for the rough estimate of the overhead of the timer.
We're subtracting these estimates from all measurements, for more granularity on the fastest instructions.

Our "ball-park" estimates of minimum clock measurement overhead:

- blue - `geth` - `30ns` ([median for `runtimeNano`](https://htmlpreview.github.io/?https://github.com/imapp-pl/gas-cost-estimator/blob/master/src/analysis/exploration_timers.nb.html))
- pink - `evmone` - `28.32ns` (2nd wild guess, this makes our results calibrate with ones inferred from [`chfast`'s benchmarks](https://notes.ethereum.org/@chfast/benchmarking-evm-instructions). We try here to have `NOT` opcode match the time from there, which is `881us/256/2048 = 1.68ns`. Our median measurement without adjustment was `30`, so `30 - 1.68 = 28.32ns`)
  - (earlier try: `9ns` wild guess, half of smallest measurement)
  - (2nd earlier try: `29.32ns` with earlier set of result data)
- green - `openethereum` - `30ns` (wild guess, just the same as above, **TODO** update)

```{r fig.width=20}
rough_estimate_time_overhead_geth = 30
rough_estimate_time_overhead_evmone = 28.32
rough_estimate_time_overhead_openethereum = 30

measurements_geth = measurements[which(measurements$env=="geth"), ]
measurements_evmone = measurements[which(measurements$env=="evmone"), ]
measurements_openethereum = measurements[which(measurements$env=="openethereum"), ]

measurements_geth$measure_all_time_ns_raw = measurements_geth$measure_all_time_ns
measurements_evmone$measure_all_time_ns_raw = measurements_evmone$measure_all_time_ns
measurements_openethereum$measure_all_time_ns_raw = measurements_openethereum$measure_all_time_ns

measurements_geth$measure_all_time_ns = measurements_geth$measure_all_time_ns_raw - rough_estimate_time_overhead_geth
measurements_evmone$measure_all_time_ns = measurements_evmone$measure_all_time_ns_raw - rough_estimate_time_overhead_evmone
measurements_openethereum$measure_all_time_ns = measurements_openethereum$measure_all_time_ns_raw - rough_estimate_time_overhead_openethereum
measurements = rbind(measurements_geth, measurements_evmone, measurements_openethereum)

check_columns = c("env", "measure_all_time_ns", "measure_all_time_ns_raw")
head(measurements)

# cleanup
rm(measurements_geth, measurements_evmone, measurements_openethereum)
```

A necessary touch to prepare the data - we want the opcodes factor to be ordered by the natural opcode order.
For now we'll use the original order from `programs.csv`, which coincides, but this must be improved (**TODO**).
We'll also have `geth` first, and proceed in the order of completing the instrumentations.
```{r fig.width=20}
measurements$env = factor(measurements$env, levels=c("geth", "evmone", "openethereum"))
measurements$opcode_measured = factor(measurements$opcode_measured, levels=programs$opcode_measured)
```

Quick overview of times; everything and by env:

```{r fig.width=20}
summary(measurements$measure_all_time_ns)

tapply(measurements$measure_all_time_ns, measurements$env, summary)
```

Quick overview of measurements per opcode:
```{r fig.width=20}
measurements_geth = measurements[which(measurements$env=="geth"), ]
measurements_evmone = measurements[which(measurements$env=="evmone"), ]
measurements_openethereum = measurements[which(measurements$env=="openethereum"), ]

print("geth")
tapply(measurements_geth$measure_all_time_ns, measurements_geth$opcode_measured, summary)
print("evmone")
tapply(measurements_evmone$measure_all_time_ns, measurements_evmone$opcode_measured, summary)
print("openethereum")
tapply(measurements_openethereum$measure_all_time_ns, measurements_openethereum$opcode_measured, summary)

# cleanup
rm(measurements_geth, measurements_evmone, measurements_openethereum)
```
**TODO** this looks bad for PUSH1-PUSH8 OPCODEs for `evmone`, the timer overhead measurement is off.

(Pushes of more than 8 bytes look more expensive, what is special about pushes under 8 bytes for `evmone`?
Mystery solved in `evmone/lib/evmone/opcodes_helpers.h`:
```c
#define ANY_SMALL_PUSH \
    OP_PUSH1:          \
    case OP_PUSH2:     \
    case OP_PUSH3:     \
    case OP_PUSH4:     \
    case OP_PUSH5:     \
    case OP_PUSH6:     \
    case OP_PUSH7:     \
    case OP_PUSH8
```)

We want to introduce a notion of implementation-relative measurements, where we express them in the multiples of "mean `COINBASE` duration", as opposed to ns.
Let's call the selected operation **"pivot OPCODE"**.

We're using `COINBASE` as the pivot OPCODE because it is (**TODO** verify all points, pick a better one):

- relatively slow, so timer measurement overhead and precision have little impact
- seems to be free of surprises or influences of suboptimal implementation
- no outliers
- seem to be a rather typical opcode in terms of timing in both implementations (it allows similar calibration to that using an overall mean)
- `COINBASE` seems a rather peculiar choice for a pivot OPCODE, but `¯\_(ツ)_/¯`
- (earlier pick was `POP`, but it is very cheap, close to timer measurement and precision) 
- (second pick was `EXP(0, 0)`, but it had a bad outlier, we can revisit after the `evmone` outliers are sorted, **TODO**)
- (third and fourth picks were `MULMOD(0, 0, 0)` and `GT(0, 0)`, but they belong to two groups which time very differently in `geth`/`evmone` - `geth` seems faster in arithmetic and slower in logical and comparison operators (**TODO** explore this more)

```{r fig.width=20}
measurements_geth = measurements[which(measurements$env=="geth"), ]
measurements_evmone = measurements[which(measurements$env=="evmone"), ]
measurements_openethereum = measurements[which(measurements$env=="openethereum"), ]

pivot_opcode = "COINBASE"
means = c(
  mean(measurements_geth[which(measurements_geth$opcode_measured==pivot_opcode), "measure_all_time_ns"]),
  mean(measurements_evmone[which(measurements_geth$opcode_measured==pivot_opcode), "measure_all_time_ns"]),
  mean(measurements_openethereum[which(measurements_openethereum$opcode_measured==pivot_opcode), "measure_all_time_ns"])
)
# TODO: remove. This is a temporary hacky way of getting an overall mean
# means = c(
#   mean(measurements_geth[, "measure_all_time_ns"]),
#   mean(measurements_evmone[, "measure_all_time_ns"]),
#   mean(measurements_openethereum[, "measure_all_time_ns"])
# )
pivot_statistics = data.frame(
  mean_measure_all_time_ns=means, row.names=c("geth", "evmone", "openethereum")
)
head(pivot_statistics)
measurements_geth$measure_all_time_ns_rel = measurements_geth$measure_all_time_ns / pivot_statistics["geth", "mean_measure_all_time_ns"]
measurements_evmone$measure_all_time_ns_rel = measurements_evmone$measure_all_time_ns / pivot_statistics["evmone", "mean_measure_all_time_ns"]
measurements_openethereum$measure_all_time_ns_rel = measurements_openethereum$measure_all_time_ns / pivot_statistics["openethereum", "mean_measure_all_time_ns"]
measurements = rbind(measurements_geth, measurements_evmone, measurements_openethereum)

check_columns = c("env", "measure_all_time_ns", "measure_all_time_ns_rel")
head(measurements[which(measurements$opcode_measured==pivot_opcode & measurements$env=="geth"), check_columns])
head(measurements[which(measurements$opcode_measured==pivot_opcode & measurements$env=="evmone"), check_columns])
head(measurements[which(measurements$opcode_measured==pivot_opcode & measurements$env=="openethereum"), check_columns])

# cleanup
rm(measurements_geth, measurements_evmone, measurements_openethereum)
```

Let's compare the implementations in an absolute fashion (note we're not showing outliers for `evmone` because they're very large - **TODO** investigate what happened. UPDATE: `geth` has massive outliers too, after adding all the opcodes):

<div class="superbigimage">
```{r fig.width=20}
measurements_geth = measurements[which(measurements$env=="geth"), ]
measurements_evmone = measurements[which(measurements$env=="evmone"), ]
measurements_openethereum = measurements[which(measurements$env=="openethereum"), ]

geth_color = rgb(0.1,0.1,0.7,0.5)
evmone_color = rgb(0.8,0.1,0.3,0.6)
openethereum_color = rgb(0.1,0.7,0.1,0.5)
```

<div class="superbigimage">
```{r fig.width=30, fig.height=10}
par(mfrow=c(3,1), mar = c(6,4,1,2) + 0.1)
boxplot(measure_all_time_ns ~ opcode_measured, data=measurements_geth, col=geth_color, outline=FALSE, las=2)
boxplot(measure_all_time_ns ~ opcode_measured, data=measurements_evmone, col=evmone_color, las=2, outline=FALSE, xaxt="n")
boxplot(measure_all_time_ns ~ opcode_measured, data=measurements_openethereum, col=openethereum_color, las=2, outline=FALSE, xaxt="n")
```

</div>
```{r fig.width=20}
# cleanup
rm(measurements_geth, measurements_evmone, measurements_openethereum)
```

To compare the opcodes on a single boxplot side by side, still absolute times:


```{r fig.width=20}
par(mar = c(8,4,1,2) + 0.1)
env_colors = c(geth_color, evmone_color, openethereum_color)
```

<div class="superbigimage">
```{r fig.width=30, fig.height=10}
boxplot(measure_all_time_ns ~ env:opcode_measured, data=measurements, las=2, col=env_colors, outline=FALSE, cex.axis=0.5)
```
</div>

```{r fig.width=20}
# TODO: own labels, still doesn't look good, fix this
# library(plyr)
# boxplot(measure_all_time_ns ~ env:opcode_measured, data=measurements, las=2, col=env_colors, outline=FALSE, xaxt="n")
# axis(side = 1, labels = FALSE)
# labels = expand.grid(levels(measurements$env), levels(measurements$opcode_measured))
# labels = mdply(labels, "paste", sep=".")
# text(x = 1:nrow(measurements),
#      y = par("usr")[3] - 50.45,
#      labels = labels$V1,
#      xpd = NA,
#      ## Rotate the labels by 35 degrees.
#      srt = 45,
#      cex = 0.5)
```

---

Now let's compare using the relative times, measured in multiples of the duration of the pivot OPCODE (see above):

<div class="superbigimage">
```{r fig.width=30, fig.height=10}
par(mar = c(8,4,1,2) + 0.1)
boxplot(measure_all_time_ns_rel ~ env:opcode_measured, data=measurements, las=2, col=env_colors, outline=FALSE, cex.axis=0.5)
abline(h=1, col="red", lty=3)
```
</div>

The red, dotted line is 1, which coincides with respective mean of pivot OPCODE (see above) measurement for the different environments.

**TODO** check these again, some look weird.

```{r fig.width=20}
measurements_geth = measurements[which(measurements$env=="geth"), ]
measurements_evmone = measurements[which(measurements$env=="evmone"), ]
measurements_openethereum = measurements[which(measurements$env=="openethereum"), ]

n_programs = nrow(programs)
n_plot_cols = 14
n_plot_rows = n_programs %/% n_plot_cols + 1
```

<div class="superbigimage">
```{r fig.width=40, fig.height=15}
par(mfrow=c(n_plot_rows, n_plot_cols))
for (opcode in programs$opcode_measured)
{
  frequencies = sort(table(measurements_geth[which(measurements_geth$opcode_measured==opcode), "measure_all_time_ns_raw"]), decreasing=TRUE)
  n = min(10, nrow(frequencies))
  plot(frequencies[1:n], yaxt="n", ylab="", xlab=c(opcode, " geth"), col=geth_color)
}
```
</div>

<div class="superbigimage">
```{r fig.width=40, fig.height=15}
par(mfrow=c(n_plot_rows, n_plot_cols))
for (opcode in programs$opcode_measured)
{
  frequencies = sort(table(measurements_evmone[which(measurements_evmone$opcode_measured==opcode), "measure_all_time_ns_raw"]), decreasing=TRUE)
  n = min(10, nrow(frequencies))
  if (length(frequencies) == 0) next
  plot(frequencies[1:n], yaxt="n", ylab="", xlab=c(opcode, " evmone"), col=evmone_color)
}
```
</div>

<div class="superbigimage">
```{r fig.width=40, fig.height=15}
par(mfrow=c(n_plot_rows, n_plot_cols))
for (opcode in programs$opcode_measured)
{
  frequencies = sort(table(measurements_openethereum[which(measurements_openethereum$opcode_measured==opcode), "measure_all_time_ns_raw"]), decreasing=TRUE)
  n = min(10, nrow(frequencies))
  if (length(frequencies) == 0) next
  plot(frequencies[1:n], yaxt="n", ylab="", xlab=c(opcode, " evmone"), col=openethereum_color)
}
```
</div>

```{r fig.width=20}
# cleanup
rm(measurements_geth, measurements_evmone, measurements_openethereum)
```

---

Quick check that `sample_id` shouldn't impact measurements:

```{r fig.width=20}
boxplot(measure_all_time_ns ~ sample_id:env, data=measurements, las=2)
```

But `run_id` does impact measurements: first several runs have a decreasing trend. **TODO** needs investigation how/if to alleviate:

```{r fig.width=20}
measurements_geth = measurements[which(measurements$env=="geth"), ]
measurements_evmone = measurements[which(measurements$env=="evmone"), ]
measurements_openethereum = measurements[which(measurements$env=="openethereum"), ]

par(mfrow=c(3,1))
boxplot(measure_all_time_ns ~ run_id, data=measurements_geth, las=2, outline=FALSE)
boxplot(measure_all_time_ns ~ run_id, data=measurements_evmone, las=2, outline=FALSE)
boxplot(measure_all_time_ns ~ run_id, data=measurements_openethereum, las=2, outline=FALSE)

# cleanup
rm(measurements_geth, measurements_evmone, measurements_openethereum)
```