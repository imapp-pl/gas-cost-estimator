---
title: "R Notebook: initial exploration for Gas Cost Estimator"
output: html_notebook
---

```{r fig.width=20}
library(sqldf)
```

Read in the `programs.csv` as generated by `src/program_generator.py` with `--fullCSV` flag on
```{r fig.width=20}
setwd("~/sources/imapp/gas-cost-estimator/src")
programs = read.csv("../../programs.csv")
```
Unfortunately `JUMP` and `JUMPI` are currently broken in `geth` (they require a `JUMPDEST`). Because they work in `evmone` (it prepends `JUMPDEST`) forcefully, we should drop them from the analisys. **TODO** fix this somehow:
```{r fig.width=20}
programs = programs[which(programs$opcode_measured != "JUMP"), ]
programs = programs[which(programs$opcode_measured != "JUMPI"), ]
head(programs)
```

Modify `programs.csv` to adjust for the fact, that `evmone` prepends a `JUMPDEST` instruction at the vary beginning of each bytecode:
(**TODO** track and adjust for the programs instructions more elegantly)

```{r fig.width=20}
programs$measured_op_position_evmone = programs$measured_op_position + 1
head(programs)
```

Read in the `result_geth.csv` and `result_evmone.csv` as generated by `src/measurements.py`

```{r fig.width=20}
setwd("~/sources/imapp/gas-cost-estimator/src")
result_geth = read.csv("../../result_geth.csv")
result_evmone = read.csv("../../result_evmone.csv")
result_geth$env = "geth"
result_evmone$env = "evmone"
results = rbind(result_geth, result_evmone)
head(results)
```

Combine the two tables to see only times of the measured opcodes.

```{r fig.width=20}
measurements = sqldf("SELECT opcode_measured, sample_id, run_id, measure_all_time_ns, env
                     FROM results
                     INNER JOIN 
                       programs ON(results.program_id = programs.program_id)
                     WHERE 
                       (results.instruction_id = programs.measured_op_position AND results.env = 'geth') OR
                       (results.instruction_id = programs.measured_op_position_evmone AND results.env = 'evmone')
                     ")

head(measurements)
                     
```

A necessary touch to prepare the data - we want the opcodes factor to be ordered by the natural opcode order.
For now we'll use the original order from `programs.csv`, which coincides, but this must be improved (**TODO**)
```{r fig.width=20}
measurements$opcode_measured = factor(measurements$opcode_measured, levels=programs$opcode_measured)
```

Quick overview of times everything and by env:

```{r fig.width=20}
summary(measurements$measure_all_time_ns)

tapply(measurements$measure_all_time_ns, measurements$env, summary)
```

Quick overview of measurements per opcode:
```{r fig.width=20}
print("Geth")
measurements_geth = measurements[which(measurements$env=="geth"), ]
tapply(measurements_geth$measure_all_time_ns, measurements_geth$opcode_measured, summary)
print("Evmone")
measurements_evmone = measurements[which(measurements$env=="evmone"), ]
tapply(measurements_evmone$measure_all_time_ns, measurements_evmone$opcode_measured, summary)
```

We want to introduce a notion of implementation-relative measurements, where we express them in the multiples of "mean POP duration", as opposed to ns.
Let's call the selected operation **"pivot operation"**
```{r fig.width=20}
pivot_opcode = "POP"
pivot_statistics = data.frame(mean_measure_all_time_ns=c(
  mean(measurements_geth[which(measurements_geth$opcode_measured==pivot_opcode), "measure_all_time_ns"]),
  mean(measurements_evmone[which(measurements_geth$opcode_measured==pivot_opcode), "measure_all_time_ns"])
), row.names=c("geth", "evmone")
)
head(pivot_statistics)
measurements_geth$measure_all_time_ns_rel = measurements_geth$measure_all_time_ns / pivot_statistics["geth", "mean_measure_all_time_ns"]
measurements_evmone$measure_all_time_ns_rel = measurements_evmone$measure_all_time_ns / pivot_statistics["evmone", "mean_measure_all_time_ns"]
measurements = rbind(measurements_geth, measurements_evmone)

check_columns = c("env", "measure_all_time_ns", "measure_all_time_ns_rel")
head(measurements[which(measurements$opcode_measured==pivot_opcode & measurements$env=="geth"), check_columns])
head(measurements[which(measurements$opcode_measured==pivot_opcode & measurements$env=="evmone"), check_columns])
```

Let's compare the implementations in an absolute fashion (note we're not showing outliers for `evmone` because they're very large - **TODO** investigate what happened):
```{r fig.width=20}
geth_color = rgb(0.1,0.1,0.7,0.5)
evmone_color = rgb(0.8,0.1,0.3,0.6)

par(mfrow=c(2,1), mar = c(6,4,0,2) + 0.1)
boxplot(measure_all_time_ns ~ opcode_measured, data=measurements_geth, col=geth_color, las=2)
boxplot(measure_all_time_ns ~ opcode_measured, data=measurements_evmone, col=evmone_color, las=2, outline=FALSE, xaxt="n")
```

To compare the opcodes on a single boxplot side by side, still absolute times:

```{r fig.width=20}
par(mar = c(8,4,1,2) + 0.1)
env_colors = c(geth_color, evmone_color)
boxplot(measure_all_time_ns ~ env:opcode_measured, data=measurements, las=2, col=env_colors, outline=FALSE)
```

Now let's compare using the relative times, measured in multiples of the duration of `POP`:

```{r fig.width=20}
par(mar = c(8,4,1,2) + 0.1)
boxplot(measure_all_time_ns_rel ~ env:opcode_measured, data=measurements, las=2, col=env_colors, outline=FALSE)
abline(h=1, col="red", lty=3)
```

Quick check that `sample_id` shouldn't impact measurements:

```{r fig.width=20}
boxplot(measure_all_time_ns ~ sample_id, data=measurements, las=2)
```

But `run_id` does impact measurements: first several runs have a decreasing trend. **TODO** needs investigation how/if to alleviate:

```{r fig.width=20}
par(mfrow=c(2,1))
boxplot(measure_all_time_ns ~ run_id, data=measurements_geth, las=2)
boxplot(measure_all_time_ns ~ run_id, data=measurements_evmone, las=2, outline=FALSE)
```