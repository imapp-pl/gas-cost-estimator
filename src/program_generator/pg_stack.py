import os
import csv
import fire
import sys
import subprocess
import tempfile
import binascii
import random

import constants

dir_path = os.path.dirname(os.path.realpath(__file__))


class Program(object):
  """
  POD object for a program
  """

  def __init__(self, bytecode, measured_op_position):
    self.bytecode = bytecode
    self.measured_op_position = measured_op_position


class ProgramGenerator(object):
  """
  Sample program generator for EVM instrumentation

  If used with `--fullCsv`, will print out a CSV in the following format:
  ```
  | program_id | opcode_measured | measured_op_position | bytecode |
  ```

  A sample usage `python3 program_generator/pg_arythmetic.py generate --count=2 --gasLimit=100 --seed=123123123`

  NOTE: `measured_op_position` doesn't take into account the specific instructions fired before the
  generated part starts executing. It is relative to the first instruction of the _generated_ part
  of the program. E.g.: `evmone` prepends `JUMPDESTI`, `openethereum_ewasm` prepends many instructions
  """

  def __init__(self):

    opcodes_file = os.path.join(dir_path, 'data', 'opcodes.csv')

    with open(opcodes_file) as csvfile:
      reader = csv.DictReader(csvfile, delimiter=',', quotechar='"')
      opcodes = {i['Value']: i for i in reader}

    opcodes = self._fill_opcodes_push_dup_swap(opcodes)

    selection_file = os.path.join(dir_path, 'data', 'selection.csv')

    with open(selection_file) as csvfile:
      reader = csv.DictReader(csvfile, delimiter=' ', quotechar='"')
      selection = [i['Opcode'] for i in reader]

    self._operations = [opcodes[op] for op in selection]

  def generate(self, fullCsv=False, count=1, gasLimit=10000, seed=None, min=0, max=2):
    """
    Main entrypoint of the CLI tool. Should dispatch to the desired generation routine and print
    programs to STDOUT

    Parameters:
    fullCsv (boolean): if set, will generate programs with accompanying data in CSV format
    count (int): the number of programs
    gasLimit(int): the gas limit for a single program
    seed: a seed for random number generator, if None then default behaviour for random()
    min: min stack size, a generated program will keep the stack size at least this value during execution
    max: max stack size, a generated program will keep the stack size at most this value during execution
    """

    if seed:
      random.seed(a=seed, version=2)

    programs = []
    for i in range(count):
      program = self._generate_random_stack(gasLimit, min, max)
      programs.append(program)

    if fullCsv:
      writer = csv.writer(sys.stdout, delimiter=',', quotechar='"')

      program_ids = [i for i, program in enumerate(programs)]
      bytecodes = [program.bytecode for program in programs]

      header = ['program_id', 'bytecode']
      writer.writerow(header)

      rows = zip(program_ids, bytecodes)
      for row in rows:
        writer.writerow(row)
    else:
      for program in programs:
        print(program.bytecode)

  def _generate_random_stack(self, gasLimit, _min=0, _max=32):
    """
    Generates one large programs with multiple stack operations
    """
    # current stack size
    stack = 0
    # generated bytecode
    bytecode = ''
    # number of operations
    ops_count = 0
    # gas used
    gas = 0
    # constant list of arithmetic operations
    stack_op_types = ['pop', 'push', 'dup', 'swap']

    while gas < gasLimit:
      op_type = random.choice(stack_op_types)
      ops_count += 1

      # the push op is enforced or the valid choice is the push op
      if stack <= _min or (op_type == 'push' and stack < _max):
        bytecode += self._random_push32()
        gas += 3
        stack += 1
        continue

      # the pop op is enforced or the valid choice is the pop op
      if stack >= _max or op_type == 'pop':
        bytecode += '50'  # pop
        gas += 2
        stack -= 1
        continue

      if op_type == 'swap' and stack == 1:  # swap is impossible, do dup instead
        op_type = 'dup'

      if op_type == 'swap':
        max_position = stack-1  # the position is * in the name SWAP*
        if max_position > 16:
          max_position = 16
        position = 1 if max_position == 1 else random.randrange(1, max_position, 1)
        op_num = 9*16 + position - 1  # 0x90 is SWAP1
        op = hex(op_num)[2:]
        bytecode += op
        gas += 3
        continue

      if op_type == 'dup':
        max_position = stack  # the position is * in the name DUP*
        if max_position > 16:
          max_position = 16
        position = 1 if max_position == 1 else random.randrange(1, max_position, 1)
        op_num = 8*16 + position - 1  # 0x80 is DUP1
        op = hex(op_num)[2:]
        bytecode += op
        stack += 1
        gas += 3
        continue

    return Program(bytecode, ops_count)

  def _random_push32(self):
    value = random.getrandbits(256)
    value = hex(value)
    value = value[2:]
    if len(value) < 64:
      value = (64-len(value))*'0' + value
    return '7f' + value

  def _fill_opcodes_push_dup_swap(self, opcodes):
    pushes = constants.EVM_PUSHES
    dups = constants.EVM_DUPS
    swaps = constants.EVM_SWAPS

    pushes = self._opcodes_dict_push_dup_swap(pushes, [0] * len(pushes), [1] * len(pushes), parameter='00')
    opcodes = {**opcodes, **pushes}
    dups = self._opcodes_dict_push_dup_swap(dups, range(1, len(dups)), range(2, len(dups)+1))
    opcodes = {**opcodes, **dups}
    swaps = self._opcodes_dict_push_dup_swap(swaps, range(2, len(swaps)+1), range(2, len(swaps)+1))
    opcodes = {**opcodes, **swaps}
    return opcodes

  def _opcodes_dict_push_dup_swap(self, source, removeds, addeds, parameter=None):
    source_list = source.split()
    opcodes = source_list[::2]
    names = source_list[1::2]
    new_part = {
      opcode: {
        'Value': opcode,
        'Mnemonic': name,
        'Removed from stack': removed,
        'Added to stack': added,
        'Parameter': parameter
      } for opcode, name, removed, added in zip(opcodes, names, removeds, addeds)
    }

    return new_part

def main():
  fire.Fire(ProgramGenerator, name='generate')

if __name__ == '__main__':
  main()
