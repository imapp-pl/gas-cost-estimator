
# CONSTANTS

EVM_DUPS = """
0x80 DUP1
0x81 DUP2
0x82 DUP3
0x83 DUP4
0x84 DUP5
0x85 DUP6
0x86 DUP7
0x87 DUP8
0x88 DUP9
0x89 DUP10
0x8a DUP11
0x8b DUP12
0x8c DUP13
0x8d DUP14
0x8e DUP15
0x8f DUP16
"""
EVM_SWAPS = """
0x90 SWAP1
0x91 SWAP2
0x92 SWAP3
0x93 SWAP4
0x94 SWAP5
0x95 SWAP6
0x96 SWAP7
0x97 SWAP8
0x98 SWAP9
0x99 SWAP10
0x9a SWAP11
0x9b SWAP12
0x9c SWAP13
0x9d SWAP14
0x9e SWAP15
0x9f SWAP16
"""
EVM_SOMETHING = '600050'
EVM_SOMETHING_LENGTH = 2

EWASM_PREAMBLE = """
(module
  (func (export "call") (local $x i32)
"""
EWASM_DROP = """
    drop
"""
EWASM_CLOSING_PARENTHESIS = """
))
"""
EWASM_SOMETHING = """
    i32.const 1234
    drop
"""
EWASM_SOMETHING_LENGTH = 2

MEMORY_OPCODES = ['CALLDATALOAD', 'CALLDATACOPY', 'RETURNDATACOPY', 'MCOPY', 'MLOAD', 'MSTORE', 'MSTORE8', 'CODECOPY', 'LOG0', 'LOG1', 'LOG2', 'LOG3', 'LOG4', 'KECCAK256']

# RETURNDATASIZE doesn't require us to preallocate or precall, we can treat it as an ordinary OPCODE
RETURNDATA_OPCODES = ['RETURNDATACOPY']

MAX_INSTRUCTIONS = 60
